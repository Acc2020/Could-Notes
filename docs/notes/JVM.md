# JVM

[toc]
**常见面试题**

- 谈谈对 JVM 的理解， Java8 虚拟机的变化，和之前的更新？
- 什么是 OOM， 什么是栈溢出（StackOverFlowError）？ 怎么分析
- JVM 的常见调优参数有哪些？
- 内存快照如何抓取，怎么分析 dump 文件，
- 谈谈在 JVM 中， 类加载器的认识


## 1. JVM 的位置
JVM 相当于一个正常虚拟机(和一般程序软件同等级),主要能够运行 Java 程序，运行的底层的操作系统之上。
![JVM01-存在位置.png](http://images.vsnode.com/JVM01-存在位置.png)

























## 2. JVM 的体系结构
一个 JAVA 程序的执行过程是通过 Java 的执行生产 class 文件，再通过类加载器进入到运行时数据区，此时无法捕捉到异常，运行时数据区主要包含方法区，Java 栈，本地方法区，堆，程序计数器，主要产生垃圾的地方数堆区，相对于的GC处理主要是对堆内存和方法区的垃圾进行处理。之后再通过本地方法接口调用本地方法库中的方法，执行程序通过执行引擎进行。

![JVM02-体系结构.png](http://images.vsnode.com/JVM02-体系结构.png)
## 3. 类加载器
类加载器通过类的全限定类名来获取二进制字节流，这过程在 JVM 外部实现，程序能够自己决定如何获取所需要的类，实现这个动作的类称为“类加载器”
一个对象的创建过程时通过类这个模板，进行创建，而对象实例化出是具体的。

![JVM02-体系结构.png](http://images.vsnode.com/JVM03-类加载器.png)





## 4. 双亲委派机制
上面的类加载器的作用是加载一个全限定类名称为二进制字节流，但是有一个问题，当出现两个或者两个以上的相同的全限定类名的情况该如何实现类的加载，这里如何进行选择就是双亲委派机制所做的工作。

> 比较两个类是否是相等，只有这两个类是同一个类加载器加载的前提下比较才有意义。如果不是相同的类加载器加载的，这两个类不同。

类加载器的种类  
1. 启动类加载器（BootStrapClassLoader）
    - 负责加载%JAVA_HOME%/bin 目录下的所有 jar 包。或者时 -Xbootclasspate 所指定的路径。
2. 扩展类加载器（ExtClassLoader）
    - 负责加载 %JAVA_HOME%\bin\ext 目录下的所有 jar 包，或者时 java.ext.dirs 参数指定的路径
3. 应用程序类加载器 (AppClassLoader) 
    - 负责加载用户类路径上所指定的类库，如果程序中没有自定义加载器，那么为默认加载器


> 工作过程：  
  1、类加载器收到类加载的请求  
  2、把请求委派到父加载器完成，一直向上委托，知道启动类加载器
  3、启动类加载器检测看是否能加载（通过 findClass（）方法 ）能就结束，不能就抛出异常，通知子类加载器执行
  4、 重复 3 步骤，如果最终都没有就是 Class not find 异常能够

## 5. 沙箱安全机制
沙箱机制时为了能够让 Java 程序在运行时限制运行程序的环境，沙箱机制将 Java 代码放在虚拟机（JVM）特定范围内，限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离。防止对本地系统的破坏。
## 6. Native 
Native 表示的是调用底层语言的库，Java 语言调用不到，会进入本地方法栈，调用方法本地接口 JNI  
JNI 作用是扩展 Java 的使用，融合不同的编程语言为 Java 所用。 

## 7. PC 寄存器
PCR （Program Counter Register）  
每一个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条指令的地址，也是即将执行的指令代码），在 Java 执行时能够使用读取下一条指令，所占用的空间非常小。
## 8. 方法区
 Method Area 方法区  
    方法区是所有线程的共享，所有字段和方法字节码，以及一些特殊的方法，如构造函数，接口代码也在这里定义，所有定义方法的信息都保存在该区域，**此区域属于共享区间**。  

    静态常量、常量、类信息（构造方法，接口定义），运行时常量池存在方法中，但是实例变量存在堆内存中和方法区无关。
![JVM04-方法区.png.png](http://images.vsnode.com/JVM04-方法区.png.png)



## 9. 栈
JVM的栈主要有

## 10. 三种 JVM
 - Sun 公司的 Java HotSpot(TM) 64-Bit Server VM (build 12.0.1+12, mixed mode, sharing)
 - BEA 公司的 JRockit （主要是速度快，及其轻量）
 - IBM J9VM （硬件兼容嵌套）

## 11. 堆 heap
一个 JVM 只有一个堆，堆的大小是可以调节的，虚拟机启动时创建 
堆在一个对象实例化的时候一般会把类，方法，常量，变量存放在堆中，保存引用对象时所有的真实对象。

堆中主要细分三个区域
 - 新生区（伊甸区）
 - 老年区 old
 - 永久区 perm

 ![JVM04-heap.png.png](http://images.vsnode.com/JVM04-heap.png.png)
  
  - 普通 GC 
  - Full GC

## 12. 新生区、老年区
 - 类：诞生和生长（论循）
 - 伊甸园区 ：（类的初次诞生的次数，幸存后到幸存者区）满了进行轻量 GC
 - 幸存者区{0，1}:  幸存者区满了之后进行一次重GC，Full GC 没有被清除后到永久区，当永久区满了之后 OOM

## 13. 永久区

长注内存重，存放JDK自身携带的 CLass 对象， interface 元数据，存储的是Java运行的一些环境或类信息。这个区不存在垃圾回收，当关闭虚拟机时就会释放内存。

- JDK 1.6 之前，永久代，常量池叫永久代
- JDK 1.7 永久代，但是已经退化，`去永久代`,常量池在堆中。
- JDK 1.8 之后 无永久代，常量池在元空间

![JVM04-堆区.png.png](http://images.vsnode.com/JVM04-堆区.png.png)

元空间逻辑上不存在。

## 14. 堆内存调优

## 15. GC

### 常用算法

- 引用计数法（一般不采用） 
 - 缺点：正常来讲 Java 中的对象比较多，计数会很消耗空间。

- 复制算法（主要在幸存区中 from / to 的轮转）
 - 好处：没有内存的碎片
 - 坏处：浪费了空间，多了一般空间时 to 空间，但如果对象清除 100% 则没效果，主要适合新生区。

- 标记清除算法（一轮扫描标记，二轮扫描清楚没有标记的，会有遗留）  
 ![JVM05-GC标记清除.png.png](http://images.vsnode.com/JVM05-GC标记清除.png.png)
    - 缺点：两次扫描严重浪费时间，会产生内存碎片（Hash 定位查找）
    - 优点：不需要浪费额外的空间
   
- 标记清除压缩算法（优化标记清除算法，防止内存碎片产生，再增加一次扫描排序向一端移动存活的对象）  
![JVM05-GC标记清除压缩.png.png](http://images.vsnode.com/JVM05-GC标记清除压缩.png.png)
    - 缺点：增加了一次扫描成本    



**针对不同情况**
 内存效率： 复制算法 > 标记清除算法 > 标记压缩算法  
 内存整齐度： 复制算法 = 标记压缩算法 > 标记清除算法  
 内存利用率： 标记压缩算法 = 标记清除算法 > 复制算法  

 年轻代：
  - 存活低
  - 复制算法

老年代
 - 区域大：存活率低
 - 标记清除 + 标记压缩混合 实现


## 16. JMM

Java Memory Model ： Java 内存模型
- 解决缓存一致性问题,在 CPU 高速发展的情况下，读写增加了缓存机制，单多线程读写会涉及到不同步的问题。 

--- 
    lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
    unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
    load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
    use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。
    assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
    store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。
    write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中


